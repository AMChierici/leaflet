---
---

## Colors

An important part of spatial visualization is mapping variables to colors. While there's no shortage of built-in functionality to manipulate colors and to map values from one scale to another, we found that there was enough friction in the process to warrant introducing some wrapper functions that do a lot of the work for you.

### Coloring Continuous Data

```{r echo=FALSE,results='hide',message=FALSE,warning=FALSE}
library(rgdal)
```
```{r message=FALSE,warning=FALSE,results='hide'}
library(rgdal)

# From http://data.okfn.org/data/datasets/geo-boundaries-world-110m
countries <- readOGR("json/countries.geojson", "OGRGeoJSON")
map <- leaflet(countries)
```

We've loaded some shape data for countries, including a numeric field `gdp_md_est` which contains GDP estimates.

#### Continuous Input, Continuous Colors (`colorNumeric`)

Let's start by mapping GDP levels directly to the `"Blues"` palette from [Color Brewer 2](http://colorbrewer2.org). We'll use the `colorNumeric` function to this. The `"Blues"` palette only contains nine colors, but `colorNumeric` interpolates these colors so we get continuous output.

```{r}
# Create a continuous palette function
pal <- colorNumeric(
  palette = "Blues",
  domain = countries$gdp_md_est
)
```

The `palette` argument is the ordered list of colors you will map colors to. In this case we used a Color Brewer palette, but we could've used `c("white", "navy")` or `c("#FFFFFF", "#000080")` for a similar effect.

The second argument, `domain`, indicates the set of input values that we are mapping to these colors. For `colorNumeric`, you can provide either a min/max as in this example, or a set of numbers that `colorNumeric` can call `range()` on.

The result is `pal`, a function that can accept numeric vectors with values in the range [0,100] and return colors in `"#RRGGBB"` format. Let's try it:

```{r}
# Apply the function to provide RGB colors to addPolygons
map %>%
  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,
    color = ~pal(gdp_md_est)
  )
```

#### Continuous Input, Discrete Colors (`colorBin` and `colorQuantile`)

`colorBin` maps numeric input data to a fixed number of output colors using binning (slicing the input domain up by value). You can specify either the exact breaks to use, or the desired number of bins. Note that in the latter case, if `pretty=TRUE` (the default) you'll end up with nice round breaks but not necessarily the number of bins you wanted.

```{r}
binpal <- colorBin("Blues", countries$gdp_md_est, 6, pretty = FALSE)

map %>%
  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,
    color = ~binpal(gdp_md_est)
  )
```

`colorQuantile` maps numeric input data to a fixed number of output colors using quantiles (slicing the input domain into subsets with equal numbers of observations).

```{r}
qpal <- colorQuantile("Blues", countries$gdp_md_est, n = 7)
map %>%
  addPolygons(stroke = FALSE, smoothFactor = 0.2, fillOpacity = 1,
    color = ~qpal(gdp_md_est)
  )
```

### Coloring Categorical Data

`colorFactor` works on categorical data. If the `palette` contains the same number of elements as there are factor levels, then the mapping will be 1:1; otherwise, the palette will be interpolated to produce the desired number of colors.

You can specify the input domain either by passing a factor or character vector to `domain`, or by providing levels directly using the `levels` argument (in which case the `domain` will be ignored).

// TODO: Example
